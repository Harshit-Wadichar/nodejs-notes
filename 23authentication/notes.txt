Here's a simple explanation of **stateful** and **stateless** authentication in Node.js, with everyday examples:

---

### **1. Stateful Authentication** (Like a **Club Stamp**)
- **How it works**:  
  The server remembers you (keeps track of your session).  
  - When you log in, the server creates a **session ID** (like a hand stamp at a club).  
  - This ID is stored on the server (e.g., in memory, Redis, or a database).  
  - Your browser gets the session ID (usually in a cookie).  
  - On every request, you show the "stamp" (session ID), and the server checks its list to confirm it’s valid.

- **Node.js Example**:  
  ```javascript 
  const express = require('express');
  const session = require('express-session');

  app.use(session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: true,
    cookie: { secure: true }
  }));

  // Login route
  app.post('/login', (req, res) => {
    req.session.user = { id: 123, email: 'user@example.com' }; // Store user data in session
    res.send('Logged in!');
  });

  // Protected route
  app.get('/profile', (req, res) => {
    if (req.session.user) { // Check if session exists
      res.send('Welcome to your profile!');
    } else {
      res.send('Access denied!');
    }
  });
  ```

- **Pros**: Easy to invalidate sessions (just delete the session on the server).  
- **Cons**: Harder to scale (needs session storage for all users).

---

### **2. Stateless Authentication** (Like a **Movie Ticket**)
- **How it works**:  
  The server **does NOT remember you**.  
  - When you log in, the server gives you a **signed token** (like a JWT – JSON Web Token).  
  - This token contains your user info (e.g., user ID) and a secret signature.  
  - You send this token with every request (usually in the `Authorization` header).  
  - The server checks the token’s signature to verify it’s valid (no database lookup needed).

- **Node.js Example**:  
  ```javascript
  const jwt = require('jsonwebtoken');

  // Login route
  app.post('/login', (req, res) => {
    const user = { id: 123, email: 'user@example.com' };
    const token = jwt.sign(user, 'your-secret-key', { expiresIn: '1h' }); // Create token
    res.json({ token });
  });

  // Middleware to verify token
  function authMiddleware(req, res, next) {
    const token = req.headers.authorization?.split(' ')[1]; // Get token from header
    if (!token) return res.status(401).send('Access denied');

    try {
      const decoded = jwt.verify(token, 'your-secret-key'); // Verify token
      req.user = decoded;
      next();
    } catch (err) {
      res.status(400).send('Invalid token');
    }
  }

  // Protected route
  app.get('/profile', authMiddleware, (req, res) => {
    res.send(`Welcome, ${req.user.email}!`);
  });
  ```

- **Pros**: Scalable (no server-side storage).  
- **Cons**: Harder to invalidate tokens before they expire.

---

### **Key Differences**
| **Stateful**                          | **Stateless**                          |
|---------------------------------------|----------------------------------------|
| Server stores sessions (e.g., Redis). | Server stores **nothing**.             |
| Uses cookies.                         | Uses tokens (JWT).                     |
| Session IDs are checked on every request. | Tokens are verified with cryptography. |
| Good for traditional web apps.        | Great for APIs/mobile apps.            |

---

### **When to Use Which?**
- **Stateful**: Traditional web apps (e.g., e-commerce sites with server-rendered pages).  
- **Stateless**: APIs, mobile apps, or microservices (where scalability matters).